#!/bin/bash

# helpers
pidfile-path() {
  echo "$1/.autotags.pid"
}

pid-running() {
  kill -0 "$1" > /dev/null 1>&2
  if [[ "$?" -eq '0' ]]; then
    true
  else
    false
  fi
}

display-running() {
  echo "looks like autotags is not running in $1"
}

display-dangling-pidfile() {
  local pidfile; pidfile=pidfile-path $1

  echo "looks like autotags in not running in $1"
  echo "warning: the lock file $pidfile exists"
  echo 'please delete the file if autotags is really not running'
}

display-not-running() {
  echo "looks like autotags is not running in $1"
}

display-help() {
  cat <<'HELP'
usage: autotags [options] <command> <path>
  command: a command to run (see below)
  path:    directory to operate on (defaut: .)

Options:
  -v:  enable verbose logging
  -h:  display this help message

Commands:
  help:    display this help message
  status:  display whether or the given path is being watched or not
  watch:   monitor the given directory for changes and generate ctags
  stop:    stop monitoring the given directory
HELP
}

# options
parse-options() {
  export verbose=0
  export path=.
  OPTIND=1
  while getopts 'hv' opt; do
    case "$opt" in
      v)
        export verbose=1
        ;;
      h|?)
        display-help
        exit
        ;;
    esac
  done
  shift $((OPTIND - 1))

  if [[ "$#" -lt "1" ]]; then
    echo 'too few arguments'
    display-help
    exit 1
  fi

  export cmd=$1
  [[ "$#" -gt "1" ]] && export path=$2
}

# commands
status() {
  local path=$1
  local pidfile; pidfile=$(pidfile-path $1)

  if [ -f "$pidfile" ]; then
    local pid; pid="$(cat "$pidfile")"

    if pid-running $pid; then
      display-running $path
      exit 0
    else
      display-dangling-pidfile $path
      exit 2
    fi
  else
    display-not-running $path
    exit 1
  fi
}

stop() {
  local path=$1
  local pidfile; pidfile=$(pidfile-path $1)

  if [ -f "$pidfile" ]; then
    local pid; pid=$(cat $pidfile)

    if pid-running $pid; then
      kill $pid
      wait $pid
      exit 0
    else
      display-dangling-pidfile
      exit 2
    fi
  else
    display-not-running $path
    exit 1
  fi
}

watch() {
  local path=$1
  local pidfile; pidfile=$(pidfile-path $path)

  if [ -f "$pidfile" ]; then
    if pid-running "$(cat $pidfile)"; then
      display-running $path
      exit 1
    else
      display-dangling-pidfile $path
      exit 2
    fi
  else
    (run-watch $path > /dev/null 2>&1 &) &
    exit 0
  fi
}

run-watch() {
  local pidfile; pidfile=$(pidfile-path $1)
  echo $BASHPID > $pidfile
  cd /
  while true; do
    sleep 10
  done
}

dispatch-command() {
  local cmd=$1
  local path=$2

  case "$cmd" in
    status) status $path ;;
    watch) watch $path ;;
    stop) stop $path ;;
    help) display-help ;;
    *)
      echo "unknown command: $cmd"
      display-help
      exit 1
      ;;
  esac
}

parse-options "$@"
dispatch-command $cmd $path
