#!/bin/bash

# commands
display-help() {
  cat <<'HELP'
usage: autotags [options] <command> <path>
  command: a command to run (see below)
  path:    directory to operate on (defaut: .)

Options:
  -v:  enable verbose logging
  -h:  display this help message

Commands:
  help:    display this help message
  status:  display whether or the given path is being watched or not
  watch:   monitor the given directory for changes and generate ctags
  stop:    stop monitoring the given directory
HELP
}

# options
parse-options() {
  export verbose=0
  export path=.
  OPTIND=1
  while getopts 'hv' opt; do
    case "$opt" in
      v)
        export verbose=1
        ;;
      h|?)
        display-help
        exit
        ;;
    esac
  done
  shift $((OPTIND - 1))

  if [[ "$#" -lt "1" ]]; then
    echo 'too few arguments'
    display-help
    exit 1
  fi

  export cmd=$1
  [[ "$#" -gt "1" ]] && export path=$2
}

status() {
  local path=$1
  local pidfile="$path/.autotags.pid"

  if [ -f "$pidfile" ]; then
    local pid; pid="$(cat "$pidfile")"

    if kill -0 "$pid" > /dev/null 2>&1; then
      echo "looks like autotags is running in $path"
      exit 0
    else
      echo "looks like autotags in not running in $path"
      echo "warning: the lock file $pidfile exists"
      echo 'please delete the file if autotags is really not running'
      echo 2
    fi
  else
    echo "looks like autotags is not running in $path"
    exit 1
  fi
}

dispatch-command() {
  local cmd=$1
  local path=$2

  case "$cmd" in
    status) status $path ;;
    watch)
      echo 'running watch'
      ;;
    stop)
      echo 'running stop'
      ;;
    help)
      display-help
      ;;
    *)
      echo "unknown command: $cmd"
      display-help
      exit 1
      ;;
  esac
}

parse-options "$@"
dispatch-command $cmd $path
